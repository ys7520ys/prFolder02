크로스 브라우징
  1. 웹페이지가 웹 브라우저의 종류에 구애받지 않고 제작자의 의도에 맞게 보여지거나 동작을 할 수 있게 만드는 작업이다.
  2. 작업 시에 크로스 브라우징을 고려해가며 작업하는 것이 좋다. 웹 페이지 완성 후 에는 각 브라우저에서 사용성 테스트를 하면서 수정해 나간다.
  3. 인터넷 익스플로러가 이 부분에서 속을 많이 썩였지만, 서비스가 종료되고 대체 브라우저로 Edge가 등장하여 한결 편해졌다.




  폴리필(Polyfill):
    브라우저에서 지원하지 않는 기능을 사용할 수 있도록 해주는 코드 조각 또는 라이브러리를 말한다. 이를 통해서 최신 웹 표준이나 기능을 지원하지 않는 구형 브라우저에서도 동일하게 기능이 동작하도록 만든다.

    사용예시:
      Javascript기능:
        ES6의 promise나 fetch API처럼, 구형 브라우저에서 지원하지 않는 최신 자바스크립트 기능을 폴리필을 통해서 구현할 수 있다. core-js나 babel-polyfill이 대표적인 자바스크립트 폴리필 라이브러리다.
      CSS기능:
        CSS Grid와 같은 최신 CSS 레이아웃 시스템을 지원하지 않는 경우, Polyfill을 사용해서 비슷한 레이아웃을 생성할 수 있다. CSS폴리필은 자바스크립트를 이용해서 스타일을 추가하는 방식이 아니라 모든 스타일을 폴리필로 구현할 수는 없다.
      HTML5 API:
        예를 들어, localStorage를 지원하지 않는 브라우저를 위해 쿠키를 사용하여 비슷한 기능을 제공할 수 있는 폴리필이 존재한다.
  
  폴리필 작동방식:
    폴리필은 구형 브라우저에서 기능이 없는 경우에만 실행된다. 예를 들어, promise 폴리필은 promise가 지원되지 않는 경우에만 promise 객체를 생성하고, 최신 브라우저에서는 그대로 무시된다.

  폴리필 사용 예시:
    Fetch API폴리필:
      fetch를 지원하지 않는 구형 브라우저에서 데이터를 가져오기 위해서 fetch 폴리필을 사용한다.
      Html:
        <script src="https://cdnjs.cloudflare.com/ajax/libs/fetch/3.0.0/fetch.min.js"></script>

    Object.assign폴리필:
      Object.assign이 없는 경우 동작하도록 폴리필을 사용할 수 있다.
      Javascript:
        if (typeof Object.assign != 'function') {
          Object.assign = function(target, varArgs) { // .length of function is 2
              'use strict';
              if (target == null) { // TypeError if undefined or null
                  throw new TypeError('Cannot convert undefined or null to object');
              }

              var to = Object(target);

              for (var i = 1; i < arguments.length; i++) {
                  var nextSource = arguments[i];

                  if (nextSource != null) { // Skip over if undefined or null
                      for (var nextKey in nextSource) {
                          // Avoid bugs when hasOwnProperty is shadowed
                          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                              to[nextKey] = nextSource[nextKey];
                          }
                      }
                  }
              }
              return to;
          };
        }
      L> 폴리필은 특정 기능이 꼭 필요할 때만 사용하면 좋고, 프로젝트에 따라 가능한 최신 브라우저에 맞춰서 필요한 만큼만 사용하는 것이 성능에 더 유리하다.

  폴리필이 크로스브라우징에 완벽한 해결책이 아닌 이유:
    1. 폴리필이 모든 기능을 완벽하게 대처하지 못함:
        최신 CSS나 Javascript API의 경우 구형 브라우저에서 폴리필로 완벽하게 재현하는 것이 어려운 기능이 있다. 예를 들어 CSS그리드나 일부 애니메이션 기능은 폴리
    2. 성능 이슈:
        폴리필은 추가적인 코드나 스크립트를 통해서 기능을 구현하므로, 구형 브라우저에서 성능 저하가 발생할 수 있다. 특히 오래된 브라우저에서는 폴리필이 많아지면 사이트 로딩시간이나 인터랙션 속도가 느려질 수 있다.
    3. UI/UX차이:
        브라우저마다 렌더링 방식이나 기본 스타일, 글꼴 등이 다를 수 있어 시각적 차이가 발생할 수 있다. 이는 폴리필로 해결할 수 없는 문제이며, 크로스브라우징을 위해 브라우저별로 UI를 확인해야 하는 이유이다.
    4. 브라우저별 버그:
        특정 브라우저에서만 발생하는 버그가 있는 경우 폴리필이 이를 해결해 주지 못할 수도 있다. 브라우저에 따라서 특정 CSS속성이나 Javascript함수가 비정상적으로 작동할 수 있다.
    





  크로스 브라우징 (일반적인)작업순서
    1. 기본 코드 작성:
        기능과 디자인 구현에 집중하며, 가능한 최신 웹 표준과 접근성을 고려하여 작성한다.
    2. 주요 브라우저에서 테스트:
        프로젝트가 어느 정도 완성된 후 주요 브라우저(Chrome, Firefox, Safari, Edge)에서 기능과 UI를 점검한다.
    3. 문제 해결:
        각 브라우저에서 발생하는 호환성 문제를 해결하면서, 필요한 경우 CSS와 Javascript 폴리필이나 브라우저 전용 코드 적용하기
    4. 추가적 점검 및 수정:
        화면 크기별, 장치별로 다시 한 번 테스트하여 이상이 없는지 확인한다.
    
    L> 하지만 "포트폴리오"라면 전체 브라우저의 호환성 보다는 주요 타겟 브라우저에 우선적으로 집중하는 것이 좀 더 좋은 생각이다.

  크로스브라우징 접근 방법:
    1. 중요한 기능과 스타일 위주로 크로스브라우징 확인:
        모든 요소를 확인할 필요는 없고, 사이트의 핵심 기능과 주요 시각적 요소를 위주로 점검을 진행한다.
    2. 주요타겟 브라우저를 선정:
        포트폴리오나 특정 프로젝트에서는 주로 사용하는 최신 브라우저들(Chrome, Firefox, Safari, Edge)를 중심으로 점검하고, 특별히 구형 브라우저에 대한 호환성까지 필요하지 않다면 굳이 모든 것을 맞출 필요는 없다.
    3. 폴리필 + 벤더 프리픽스 사용:
        주요 기능의 크로스브라우징을 위해서 폴리필을 사용하고, 필요에 따라서 벤더 프리픽스를 추가한다. 예를 들어 CSS flex속성에 -webkit-프리픽스를 추가하는 것처럼 진행한다.
    4. 테스트 자동화 도구 사용:
        예를 들어, BrowswerStack같은 크로스브라우징 테스트 도구를 사용하여 주요 브라우저에서 테스트를 진행하기 편리하다.
    
    L> 따라서 폴리필은 크로스브라우징을 위한 보조 도구로 생각하고, 핵심적인 기능과 주요 브라우저에서의 UI는 직접 확인하는 것이 최상의 접근이다.





  일반적인 작업 흐름:
    1. 코드 작성 완료:
        기능과 디자인을 우선 구현하고, 최신 웹 표준을 가능한 따르며 기본적인 크로스브라우징을 고려하여 작업을 진행한다.
    2. 주요 브라우저에서 테스트:
        BrowswerStack같은 툴을 사용하여 다양한 브라우저와 화면 크기에서 사이트가 예상대로 동작하고 보이는지 확인해야 한다. 여기서 발생되는 크로스브라우징 문제를 해결하기 필요한 폴리필이나 프리픽스를 추가한다.
    3. 문제 수정:
        주요 기능이나 레이아웃이 특정 브라우저에서 깨지거나 문제가 있다면, CSS 프리픽스, 폴리필, 브라우저 별 코드 수정 등을 통해서 해결한다.
    4. 최종 확인: 
        수정한 후 다시 BrowswerStack을 통해서 확인하고, 실제 장치에서도 테스트할 수 있다면 주요 기기에서 직접 테스트하는 것도 좋다.
    
  BrowswerStack은 특히 테스트 환경을 다양하게 설정할 수 있다는 점에서 효율적이다. 실제 기기가 많지 않더라도, 다양한 브라우저와 버전을 가상으로 테스트를 진행할 수 있기 때문에 시간을 절약하고 다양한 환경에서의 호환성을 확인할 수 있는 장점이 존재한다.





웹 퍼블리셔가 크로스브라우징을 검사할 때 모든 브랑저에서 시각적인 일관성과 주요 기능의 동작 여부를 확인하는 것이 주 목적이지만, 모든 브라우저에서의 성능 차이까지 세세하게 확인할 필요는 없으며, 특히 포트폴리오 수준의 프로젝트에서는 시각적 일관성만으로도 충분할 수 있다. 
L> 여러 브라우저에서 동일한 스타일 디자인의 값으로만 구현되도 포트폴리오를 작성하는 곳에서는 충분하다는 이야기

주의해야 할 성능 이슈 예시
  1. 렌더링 속도:
      구형 브라우저에서 CSS 애니메이션이나 복잡한 레이아웃이 성능에 부담이 될 수 있다. 이런 경우엔 애니메이션을 최소화하거나, GPU가속을 고려하여 최적화하는 것도 좋은 방법이다.
  2. 스크립트 성능:
      오래된 Javascript코드나 무거운 라이브러리를 사용한 경우 일부 브라우저에서 로딩이 느릴 수 있다. 이 경우 필요하지 않은 스크립트는 지연 로딩하거나, 가볍게 만드는 것이 좋다.
  3. 이미지 로딩 속도:
      고해상도 이미지가 많은 경우 구형 브라우저에서는 로딩 시간이 길어질 수 있다. 이러한 경우 srcset을 활용하여 화면 크기에 따라서 다른 이미지 해상도를 제공하거나, lazy loading을 적용하여 최적화 할 수 있다.

실제 작업 시의 접근:
  1. 기본적으로는 시각적/기능적 확인:
      주요 브라우저에서 디자인이 깨지지 않고 기능이 정상적으로 작동하는지 확인하는 것이 우선이다.
  2. 성능 이슈는 큰 문제 시에만 최적화:
      성능이 눈에 띄게 저하되는 브라우저가 있다면 그때 최적화를 고려하는 식으로 접근해도 충분하다.
  
  L> 웹퍼블리셔는 크로스브라우징 검사를 통해 기본적인 UI와 기능을 중점으로 확인하되, 성능은 문제가 되는 경우에 한해서 최적화를 진행하는 형태로 하는 것이 일반적이다.





크로스브라우징이 가능한 인재:
  1. 웹 표준 및 브라우저 특성 이해:
      -webkit-, -moz-와 같은 벤더 프리픽스를 사용하여 다양한 브라우저에서 스타일과 기능이 일관되게 작동하도록 구현할 수 있는 능력
  2. 크로스브라우징 문제 해결 능력:
      BrowswerStack과 같은 크로스브라우징 테스트 도구를 사용하여 브라우저별 차이점을 파악하고, 효과적으로 수정할 수 있는 사람
  3. 폴리필 및 대체 방법 사용 능력:
      특정 브라우저에서 최신 기능이 지원되지 않을 경우 폴리필을 적용하거나 대체 코드를 작성하여 기능을 보완할 수 있는 능력
  4. 문제 해결 및 최적화 능력:
      브라우저마다 발생할 수 있는 성능 차이나 동작 차이를 파악하고, 필요시 코드 최적화 및 비교적 가벼운 코드로 수정할 수 있는 능력
  
  L> 회사는 크로스브라우징을 통해서 모든 주요 브라우저와 다양한 기기에서 동일한 기기에서 동일한 사용자 경험을 제공할 수 있는 인재를 찾는다. 이를 위해서 웹킷이나 벤더 프리픽스를 능숙하게 활용하고, BrowswerStack같은 도구를 통해서 브라우저별 차이점을 파악하고 빠르게 대응할 수 있는 사람이 되어야 한다. 